
// set up a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

initialize() {


	defineConstant("map_1",1);
	defineConstant("map_2",2);

	defineConstant("N", 10);
//// eg Vs = 192 gives a 40% fitness difference between best and orst case scenario
	defineConstant("Vs", 192);
	defineConstant("sig_a", 1);
	defineConstant("REP", 98); // For saving files
	defineConstant("MIG", 3.5); 


	defineConstant("BC", "/home/booker/projects/def-whitlock/booker/LocalAdaptationArchitechture/SlimConfigs/BC_Map_environments.14x14.txt");
  	defineConstant("cline", "/home/booker/projects/def-whitlock/booker/LocalAdaptationArchitechture/SlimConfigs/oneDCline_environments.14x14.txt");
  	defineConstant("random", "/home/booker/projects/def-whitlock/booker/LocalAdaptationArchitechture/SlimConfigs/random_environments.14x14.txt");

// I don't think Eidos has Hashes or the like, so I'll need to use 
	if (map_1==1){
		defineConstant("optimaFile_1",BC);
	}
	else if (map_1==2){
		defineConstant("optimaFile_1",cline);
	}
	else if (map_1==3){
		defineConstant("optimaFile_1",random);
	}
	
	if (map_2==1){
		defineConstant("optimaFile_2",BC);
	}
	else if (map_2==2){
		defineConstant("optimaFile_2",cline);
	}
	else if (map_2==3){
		defineConstant("optimaFile_2",random);
	}
	
		
// Keep track of the tree sequence for the population

//	initializeTreeSeq();

	initializeMutationRate(1e-10);
	
// m2 mutation type: QTL-type
   initializeMutationType("m2", 0.5, "n", 0.0,  sig_a);
	
// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m2, 1.0);

// Initialise 12 QTL  across the genome, slap a single selected base in the middle of each "gene" 
	initializeGenomicElement(g1, 1, 1e7-1 );

	r=1e-7;
	nChrom=10;
	seqLength=10e5;

	rRates=c(rep(c(r, 0.5), nChrom-1), r);
	rBreaks=sort( c(c(1:nChrom*seqLength)-1, c(1:(nChrom-1)*seqLength)));

	
	initializeRecombinationRate(rRates, rBreaks);

	// QTL-related constants used below
	defineConstant("QTL_mu", c(0, 0));
	defineConstant("QTL_cov", 0.0);
	defineConstant("QTL_sigma", matrix(c(sig_a,
														QTL_cov,
														QTL_cov,
														sig_a), nrow=2));
														

}

// the QTLs themselves are selectively neutral; their selective effect is generated by their contribution to the phenotype and that is handled below
fitness(m2) {
	return 1.0;
}

mutation(m2) {
	// draw mutational effects for the new m2 mutation
	effects = rmvnorm(1, QTL_mu, QTL_sigma);
//	print(effects);
	mut.setValue("e1", effects[0]);
	mut.setValue("e2", effects[1]);

	// remember all drawn effects, for our final output
	//old_effects = sim.getValue("all_effects");
	//print(old_effects);
//	sim.setValue("all_effects", rbind(old_effects, effects));
	
	return T;
}

late() {
	for (ind in sim.subpopulations.individuals)
	{
		// construct phenotypes from additive effects of QTL mutations
		muts = ind.genomes.mutationsOfType(m2);

		phenotype1 = size(muts) ? sum(muts.getValue("e1")) else 0.0;
		phenotype2 = size(muts) ? sum(muts.getValue("e2")) else 0.0;
		
		ind.setValue("phenotype1", phenotype1);
		ind.setValue("phenotype2", phenotype2);
		// calculate fitness effects

		effect1 = ((ind.subpopulation.getValue("opt_1") - phenotype1)^2)/(2*Vs);
		effect2 = ((ind.subpopulation.getValue("opt_2") - phenotype2)^2)/(2*Vs);
		ind.fitnessScaling = exp(-1*(effect1 + effect2)/2);


	}
//		print(c(ind.subpopulation.getValue("opt_2"),phenotype2, exp(-1*(effect1 + effect2)/2)));

}

1 early(){

// We probably won't get a lot of substitutions, but let's turn them off because we want to keep a record of the phenotypes
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";
	
// Read a list of optima from a simple text file (one line/one entry per population).
// Make this a command line argument

	optima_1 = readFile(optimaFile_1);
	optima_2 = readFile(optimaFile_2);
	
	subpopCount = length(optima_1);

	for (i in 0:(subpopCount-1)){
		sim.addSubpop(i,  N);
		sim.subpopulations[i].setValue("opt_1", asInteger(0));
		sim.subpopulations[i].setValue("opt_2", asInteger(0));
	}

   sLen = asInteger(sqrt(subpopCount));

// Set the migration rate based on the specified Fst
//   	mig = ((1/Fst) - 1)/(4*N*subpopCount);
	mig = MIG / ( 2*N );
        for (i in 1:subpopCount-1) {
                row = asInteger(i/sLen);
                col = asInteger(i - (sLen * row));
                focal = i;
                cat(focal + ' ' + row +' ' + col + ' ' + (focal - sLen) +'\n');

                // A 2D stepping stone model
                //      Left
                if (col != 0){
                        sim.subpopulations[focal].setMigrationRates(focal-1, mig);
                }
                //      Right
                if (col < sLen-1){
                        sim.subpopulations[focal].setMigrationRates(focal+1 , mig);
                }
                //      Up
                if (row > 0){
                        sim.subpopulations[focal].setMigrationRates(focal - sLen  , mig);
                }
                //      Down
                if (row < sLen-1){
                        sim.subpopulations[focal].setMigrationRates(focal+sLen, mig);
                }
        }

}



41 early(){

// We probably won't get a lot of substitutions, but let's turn them off because we want to keep a record of the phenotypes
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";
	
// Read a list of optima from a simple text file (one line/one entry per population).
// Make this a command line argument

	optima_1 = readFile(optimaFile_1);
	optima_2 = readFile(optimaFile_2);
	
	subpopCount = length(optima_1);

	for (i in 0:(subpopCount-1)){
		sim.subpopulations[i].setValue("opt_1", asInteger(optima_1[i]));
		sim.subpopulations[i].setValue("opt_2", asInteger(optima_2[i]));
	}
}

41:1001 late() {

	if (sim.generation == 1001){
		head = "generation,pop,ind,opt_1,opt_2,phen1,phen2";
		writeFile(paste(c(REP,"_", sig_a,"_", Vs,".phen.txt"), sep=""), head);	
}


// Let's track local adaptation through time too

	if ((sim.generation-1)%1000 == 0){

		for (ind in sim.subpopulations.individuals){
				// construct phenotypes from additive effects of QTL mutations
				muts = ind.genomes.mutationsOfType(m2);
				phenotype1 = size(muts) ? sum(muts.getValue("e1")) else 0.0;
				phenotype2 = size(muts) ? sum(muts.getValue("e2")) else 0.0;
				
				out = paste(c( sim.generation, ind.subpopulation.id, ind.index, ind.subpopulation.getValue("opt_1"), ind.subpopulation.getValue("opt_2"), phenotype1, phenotype2), sep =',');
				writeFile(paste(c(REP,"_", sig_a,"_", Vs,".phen.txt"), sep=""), out, append=T);
		}				
	}
}

1001 late() {
	mut_head = "ID,position,selCoeff,e1,e2";
	writeFile(paste(c(REP,"_", sig_a,"_", Vs,".mutations.txt"), sep=""), mut_head);	

	for (mut in sim.mutations){
		mut_out = paste( c( asInteger(mut.id), asInteger(mut.position), mut.selectionCoeff, mut.getValue("e1"), 	mut.getValue("e2")), sep = ",");
		writeFile(paste(c(REP,"_", sig_a,"_", Vs,".mutations.txt"), sep=""), mut_out, append = T);	

		}
	sim.outputFull(filePath = paste(c(REP,"_", sig_a,"_", Vs,".sim.txt"), sep=""));
//	sim.treeSeqOutput(paste(c(REP,"_", sig_a,"_", Vs,".trees"), sep=""));

}

