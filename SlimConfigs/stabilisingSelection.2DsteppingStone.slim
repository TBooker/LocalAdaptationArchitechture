
// set up a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

initialize() {

	defineConstant("map",1);
	if (map==1){
		defineConstant("optimaFile", "/Users/s0784966/UBC/LocalAdaptationArchitechture/SlimConfigs/BC_Map_environments.8x8.txt");
//		defineConstant("optimaFile", "/Users/s0784966/UBC/GEA/simulations/slim_configs/BC_Map_environments.14x14.txt");
		}
	else if (map ==2){
	     	defineConstant("optimaFile", "/Users/s0784966/UBC/LocalAdaptationArchitechture/SlimConfigs/trunc_environments.14x14.txt");
	}
	else if	(map ==3){
                defineConstant("optimaFile", "/Users/s0784966/UBC/LocalAdaptationArchitechture/SlimConfigs/oneDCline_environments.14x14.txt");
	}
//	defineConstant("optimaFile", "/Users/s0784966/UBC/GEA/simulations/slim_configs/BC_Map_environments.14x14.txt");
	
	defineConstant("N", 100);
// Vs = 192 gives a 40% fitness difference between best and orst case scenarios	
	defineConstant("Vs", 192);

	defineConstant("sig_a", 1);

	defineConstant("REP", 2); // For saving files


// For an island model Fst is well described and we can set the migration rate using the theoretical expectation

//	defineConstant("Fst", 0.03);

// Keep track of the tree sequence for the population

//	initializeTreeSeq();

	initializeMutationRate(1e-10);
	
// m2 mutation type: QTL-type
   initializeMutationType("m2", 0.5, "n", 0.0,  sig_a);
	
// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m2, 1.0);

// Initialise 12 QTL  across the genome, slap a single selected base in the middle of each "gene" 
	initializeGenomicElement(g1, 1, 1e7-1 );

	r=1e-7;
	nChrom=10;
	seqLength=10e5;

	rRates=c(rep(c(r, 0.5), nChrom-1), r);
	rBreaks=sort( c(c(1:nChrom*seqLength)-1, c(1:(nChrom-1)*seqLength)));

	
	initializeRecombinationRate(rRates, rBreaks);

}


1 late() {
	optima = readFile(optimaFile);	
	subpopCount = length(optima);
	tempID = "p999";
	sim.addSubpop(tempID, subpopCount*N);
}


// the QTLs themselves are selectively neutral; their selective effect is generated by their contribution to the phenotype and that is handled below
fitness(m2) {
	return 1.0;
}


100 late(){

// We probably won't get a lot of substitutions, but let's turn them off because we want to keep a record of the phenotypes
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";
	
// Read a list of optima from a simple text file (one line/one entry per population).
// Make this a command line argument

	optima = readFile(optimaFile);
	subpopCount = length(optima);

	for (i in 0:(subpopCount-1)){
		sim.addSubpopSplit(i, N, p999);
		sim.subpopulations[i].tag = asInteger(optima[i]);
	}

// Reduce the initial subpopulation to 0 individuals 
	p999.setSubpopulationSize(0);
   sLen = asInteger(sqrt(subpopCount));

// Set the migration rate based on the specified Fst
//   	mig = ((1/Fst) - 1)/(4*N*subpopCount);
	mig = 7.5 / ( 2*N );
        for (i in 1:subpopCount-1) {
                row = asInteger(i/sLen);
                col = asInteger(i - (sLen * row));
                focal = i;
                cat(focal + ' ' + row +' ' + col + ' ' + (focal - sLen) +'\n');

                // A 2D stepping stone model
                //      Left
                if (col != 0){
                        sim.subpopulations[focal].setMigrationRates(focal-1, mig);
                }
                //      Right
                if (col < sLen-1){
                        sim.subpopulations[focal].setMigrationRates(focal+1 , mig);
                }
                //      Up
                if (row > 0){
                        sim.subpopulations[focal].setMigrationRates(focal - sLen  , mig);
                }
                //      Down
                if (row < sLen-1){
                        sim.subpopulations[focal].setMigrationRates(focal+sLen, mig);
                }
        }

}

// After 20000 generations of adapting to a dumb optimum, impose a model of stabilising selection 
// All populations are adapting to the same optimum of 0.0 


101:10101 late() {
// construct phenotypes for the additive effects of QTLs. Do this in a vectorised kind of way
	inds = sim.subpopulations.individuals;	
	inds.z = inds.sumOfMutationsOfType(m2);

// Gaussian fitness function
	inds.fitnessScaling = exp( - ((inds.z - 0)^2)/(2*Vs));

}

10102 early(){
	head = "generation,pop,opt,phen";
	subpopCount = length(sim.subpopulations);

	writeFile(paste(c(REP,"_", sig_a,"_", Vs,".phen.txt"), sep=""), head);	

	for (pop in 0:(subpopCount-1)){
		for (ind in sim.subpopulations[pop].individuals){
			out = paste(c( sim.generation, pop, sim.subpopulations[pop].tag, ind.sumOfMutationsOfType(m2)), sep =',');
			writeFile(paste(c(REP,"_", sig_a,"_", Vs,".phen.txt"), sep=""), out, append=T);
			}
		}

}


10102:60102 late() {
// construct phenotypes for the additive effects of QTLs. Do this in a vectorised kind of way
	inds = sim.subpopulations.individuals;	
	inds.z = inds.sumOfMutationsOfType(m2);
	optimum = inds.subpopulation.tag;
//	inds.fitnessScaling = 1.0 + dnorm(optimum - inds.z, 0.0, 0.5);
	inds.fitnessScaling = exp( - ((optimum - inds.z)^2)/(2*Vs));

// Let's track local adaptation through time too

	if ((sim.generation-50102)%500 == 0){
	subpopCount = length(sim.subpopulations);
	for (pop in 0:(subpopCount-1)){
		for (ind in sim.subpopulations[pop].individuals){
			out = paste(c( sim.generation, pop, sim.subpopulations[pop].tag, ind.sumOfMutationsOfType(m2)), sep =',');
			writeFile(paste(c(REP,"_", sig_a,"_", Vs,".phen.txt"), sep=""), out, append=T);
			}
		}

	}
}

60102 late() {
	sim.outputFull(filePath = paste(c(REP,"_", sig_a,"_", Vs,".sim.txt"), sep=""));
}

