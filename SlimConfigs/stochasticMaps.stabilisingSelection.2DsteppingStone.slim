
// set up a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

initialize() {


//	defineConstant("MAP",1);
//	defineConstant("N", 50);
//	defineConstant("Vs", 192);
//	defineConstant("sig_a", 1);
//	defineConstant("REP", 98); // For saving files
//	defineConstant("MIG", 3.5);



	defineConstant("optimaFile_1", "/home/booker/projects/def-whitlock/booker/LocalAdaptationArchitechture/my_maps/"+MAP+"_map.txt");
        defineConstant("optimaFile_2", "/home/booker/projects/def-whitlock/booker/LocalAdaptationArchitechture/my_maps/"+MAP+"_map.txt");



// Keep track of the tree sequence for the population

	initializeTreeSeq();

	initializeMutationRate(1e-10);

// m2 mutation type: QTL-type
   initializeMutationType("m2", 0.5, "n", 0.0,  sig_a);

// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m2, 1.0);

	initializeGenomicElement(g1, 1, 1e7-1 );

	r=1e-7;
	nChrom=10;
	seqLength=10e5;

	rRates=c(rep(c(r, 0.5), nChrom-1), r);
	rBreaks=sort( c(c(1:nChrom*seqLength)-1, c(1:(nChrom-1)*seqLength)));


	initializeRecombinationRate(rRates, rBreaks);

	// QTL-related constants used below
	defineConstant("QTL_mu", c(0, 0));
	defineConstant("QTL_cov", 0.0);
	defineConstant("QTL_sigma", matrix(c(sig_a,
														QTL_cov,
														QTL_cov,
														sig_a), nrow=2));


}

// the QTLs themselves are selectively neutral; their selective effect is generated by their contribution to the phenotype and that is handled below
fitness(m2) {
	return 1.0;
}

mutation(m2) {
	// draw mutational effects for the new m2 mutation
	effects = rmvnorm(1, QTL_mu, QTL_sigma);
//	print(effects);
	mut.setValue("e1", effects[0]);
	mut.setValue("e2", effects[1]);

	// remember all drawn effects, for our final output
	//old_effects = sim.getValue("all_effects");
	//print(old_effects);
//	sim.setValue("all_effects", rbind(old_effects, effects));

	return T;
}

late() {
	for (ind in sim.subpopulations.individuals)
	{
		// construct phenotypes from additive effects of QTL mutations
		muts = ind.genomes.mutationsOfType(m2);

		phenotype1 = size(muts) ? sum(muts.getValue("e1")) else 0.0;
		phenotype2 = size(muts) ? sum(muts.getValue("e2")) else 0.0;

		ind.setValue("phenotype1", phenotype1);
		ind.setValue("phenotype2", phenotype2);
		// calculate fitness effects

		effect1 = ((ind.subpopulation.getValue("opt_1")/10. - phenotype1)^2)/(2*Vs);
		effect2 = ((ind.subpopulation.getValue("opt_2")/10. - phenotype2)^2)/(2*Vs);
		ind.fitnessScaling = exp(-1*(effect1));


	}
//		print(c(ind.subpopulation.getValue("opt_2"),phenotype2, exp(-1*(effect1 + effect2)/2)));

}

1 early(){

// We probably won't get a lot of substitutions, but let's turn them off because we want to keep a record of the phenotypes
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";

// Read a list of optima from a simple text file (one line/one entry per population).
// Make this a command line argument

	optima_1 = readFile(optimaFile_1);
	optima_2 = readFile(optimaFile_2);

	subpopCount = length(optima_1);

	for (i in 0:(subpopCount-1)){
		sim.addSubpop(i,  N);
		sim.subpopulations[i].setValue("opt_1", asInteger(0));
		sim.subpopulations[i].setValue("opt_2", asInteger(0));
	}

   sLen = asInteger(sqrt(subpopCount));

// Set the migration rate based on the specified Fst
//   	mig = ((1/Fst) - 1)/(4*N*subpopCount);
	mig = MIG / ( 2*N );
        for (i in 1:subpopCount-1) {
                row = asInteger(i/sLen);
                col = asInteger(i - (sLen * row));
                focal = i;
                cat(focal + ' ' + row +' ' + col + ' ' + (focal - sLen) + " " + sim.subpopulations[i].getValue("opt_1") + '\n');

                // A 2D stepping stone model
                //      Left
                if (col != 0){
                        sim.subpopulations[focal].setMigrationRates(focal-1, mig);
                }
                //      Right
                if (col < sLen-1){
                        sim.subpopulations[focal].setMigrationRates(focal+1 , mig);
                }
                //      Up
                if (row > 0){
                        sim.subpopulations[focal].setMigrationRates(focal - sLen  , mig);
                }
                //      Down
                if (row < sLen-1){
                        sim.subpopulations[focal].setMigrationRates(focal+sLen, mig);
                }
        }

}



401 early(){
    print("HEELLLOOO");
// We probably won't get a lot of substitutions, but let's turn them off because we want to keep a record of the phenotypes
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";

// Read a list of optima from a simple text file (one line/one entry per population).
// Make this a command line argument

	optima_1 = readFile(optimaFile_1);
	optima_2 = readFile(optimaFile_2);

	subpopCount = length(optima_1);

	for (i in 0:(subpopCount-1)){
		sim.subpopulations[i].setValue("opt_1", asInteger(asFloat(optima_1[i])*10));
		sim.subpopulations[i].setValue("opt_2", asInteger(asFloat(optima_2[i])*10));
	}
}

40001:50001 late() {

	if (sim.generation == 40001){
		head = "generation,pop,ind,opt_1,opt_2,phen1,phen2";
		writeFile(paste(c(dir,"/",REP,"_", sig_a,"_", Vs,".phen.txt"), sep=""), head);
}


// Let's track local adaptation through time too

	if ((sim.generation-1)%200 == 0){

		for (ind in sim.subpopulations.individuals){
				// construct phenotypes from additive effects of QTL mutations
				muts = ind.genomes.mutationsOfType(m2);
				phenotype1 = size(muts) ? sum(muts.getValue("e1")) else 0.0;
				phenotype2 = size(muts) ? sum(muts.getValue("e2")) else 0.0;

				out = paste(c( sim.generation, ind.subpopulation.id, ind.index, ind.subpopulation.getValue("opt_1"), ind.subpopulation.getValue("opt_2"), phenotype1, phenotype2), sep =',');
				writeFile(paste(c(dir,"/",REP,"_", sig_a,"_", Vs,".phen.txt"), sep=""), out, append=T);
		}
	}
}

50001 late() {

      mut_head = "ID,position,selCoeff,e1,e2";
	writeFile(paste(c(dir,"/",REP,"_", sig_a,"_", Vs,".mutations.txt"), sep=""), mut_head);	

	for (mut in sim.mutations){
		mut_out = paste( c( asString(asInteger(mut.id)), asString(asInteger(mut.position)), asString(mut.selectionCoeff), asString(mut.getValue("e1")), 	asString(mut.getValue("e2"))), sep = ",");
		writeFile(paste(c(dir,"/",REP,"_", sig_a,"_", Vs,".mutations.txt"), sep=""), mut_out, append = T);	

		}

sim.outputFull(filePath = paste(c(dir,"/",REP,"_", sig_a,"_", Vs,".sim.txt"), sep=""));
	sim.treeSeqOutput(paste(c(dir,"/",REP,"_", sig_a,"_", Vs,".trees"), sep=""));

}
